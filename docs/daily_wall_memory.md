Вот изначальное техзадание - Я хочу создать приложение ежедневник. Оно должно работать на windows и Андроид. Опишу его суть. Я работаю за копьютером и мне постоянно нужно оставлять для себя заметки, ссылки, картинки, pdf/doc/xls/txt файлы. Я хочу, что бы это выглядело, как плитка-стена, на которую я закидываю нужные мне данные. Каждая плитка - это сутки. По наступлению новых суток - создается новая стена. Плитки должны пролистываться протягиванием или стрелочками, а также нужен поиск по плиткам. Все ссылки и файлы должны отображаться с миниатюрами содержимого, а при нажатии на них открываться на весь экран внутри приложения и закрываться стрелочкой - назад. Нужна панель форматирования текста с такими элементами - три варианта размера текста (для заголовков, основного текста и примечания курсивом), кнопка активации жирного текста, кнопки выравнивания слева - по центру - справа. Так как я работаю с ПК и через смартфон, в зависимости от того, на рабочем месте я или в дороге, мне нужно приложение как под windows, так и под андроид, которые будут между собой синхронизироваться. Доступ к приложению, как со стационарной версии, так и со смартфона, должен быть через пин код. Данные при синхронизации должны шифроваться, а на самих устройствах хранится в защищенных контейнерах. Подключение приложения на сматфоне к стационарному ПК я вижу на подобие аутентификации меседжеров (через сканирование QR кода) Нижче — чіткий технічний план, як зробити кросплатформний щоденник (Windows + Android) з E2EE-шифруванням, PIN-доступом, пошуком, мініатюрами та парою через QR. # Концепт і стек - **UI/кросплатформа:** **Flutter** (один код на Android і Windows). - **Локальні дані:** SQLite (**SQLCipher** для шифрування) + файлове сховище для вкладень. - **Криптографія:** libsodium/cryptography (XChaCha20-Poly1305 або AES-256-GCM, Argon2id/scrypt). - **Синхронізація:** офлайн-перший, E2EE через легкий бекенд (наприклад, Firebase/Supabase/own backend) — на сервері зберігаються тільки шифротексти та бінарні блоби. - **Повнотекстовий пошук:** SQLite **FTS5** (індекс теж у зашифрованій БД). # UX/функціонал - **Стіна-день:** кожен календарний день — окремий “канвас” (мейсонрі-грід). - **Навігація по днях:** свайп вліво/вправо, або стрілки ◀ ▶, а також календар-пікер. - **Додавання контенту:** перетягнути/“поділитися в додаток” → картка на поточний день. - **Типи карток:** текст/нотатка, посилання (з прев’ю), зображення, PDF, DOC/DOCX, XLS/XLSX, TXT. - **Вбудований перегляд на весь екран** із стрілкою “назад”. - **Форматування тексту:** H1/H2/Body, **Bold**, *Italic* (для приміток), вирівнювання ліво/центр/право. - **Пошук:** глобальний по всіх днях (текст, метадані посилань/файлів), фільтри (тип, діапазон дат). - **Автоблокування:** при згортанні/простої — запит PIN. # Модель даних (спрощено) **tables** - days { id, date_utc, created_at } - items { id, day_id, type(note|link|file|image|pdf|doc|xls|txt), title, text_rich, created_at, updated_at, z_index, layout(x,y,w,h) } - attachments { id, item_id, mime, size, hash_sha256, local_path_enc, thumb_path_enc } - links { item_id, url, og_title, og_desc, og_image_thumb_path_enc } - search_index (FTS5) з нормалізованим текстом. > Усі текстові поля й метадані — у **шифрованій** БД. Шляхи до файлів — також у БД, самі файли — в **зашифрованому** файловому контейнері. # Безпека, PIN і ключі - **PIN (4–8 цифр)** зберігаємо лише як Argon2id-хеш + соль/pepper. - Генеруємо **Device Key (DEK)** для шифрування БД/файлів. DEK зберігаємо **обгорнутим**: - Android: ключ-обгортку у **Android Keystore**; Windows: через **DPAPI**/OS keyring. - **Розблокування:** користувач вводить PIN → формується KEK (Argon2id) → розгортає DEK, далі все прозоро. - **E2EE синхронізація:** робочий простір має **Workspace Key (WK)**. На сервер ідуть тільки шифротексти (метадані/індекс не вивантажуємо у відкритому вигляді). # Парування через QR (мобільний ↔ ПК) 1. ПК генерує **епемерний сеанс** + публічний ключ (X25519), показує **QR**: {session_id, server_uri, pc_pub}. 2. Смартфон сканує → надсилає свій mobile_pub у сеанс. 3. Обидва роблять **ECDH** → отримують спільний секрет, з нього — **WK** (HKDF). 4. Смартфон запитує зашифровані дані робпростору; ПК надає (або сервер як ретранслятор). Ключі **ніколи** не покидають пристрої у відкритому вигляді. # Мініатюри та попередній перегляд - **Зображення:** локальний ресайз до 256–512px. - **PDF:** рендер 1-ї сторінки у bitmap. - **Посилання:** тягнемо OpenGraph (з таймаутом), кешуємо прев’ю. - **TXT:** пряма візуалізація. - **DOCX/XLSX:** етапи: - **MVP:** іконка + витяг заголовку/перших рядків (безпечні парсери без макросів). - **V1:** рендер у вбудований в’ювер (DOCX→HTML, XLSX→табличний рендер). - **Windows-опція:** локальний headless LibreOffice для мініатюр (без мережі). > Усі мініатюри — **локально**, шифровані перед записом. # Синхронізація та конфлікти - **Офлайн-перший**: локальні зміни → черга синка. - Конфлікти: - Для нотаток: last-writer-wins із **Lamport timestamp** або версіями/векторними годинниками. - Для вкладень: версіонування блобів (content-hash). - **Транспорт:** будь-який BaaS/власний API; дані вже зашифровані. - **Частковий синк за датами** (витягаємо лише потрібні “стіни”). # Продуктивність - Віртуалізований грід (видима область), кеш мініатюр. - Фонова генерація прев’ю. - Індекс пошуку оновлюється інкрементально. # Архітектура клієнта - **State:** BLoC/Riverpod. - **Шари:** UI ↔ Domain ↔ Repository ↔ Local(DB/FS) ↔ Sync. - **Тестування:** юніт на криптографію/конфлікти, golden-тести UI. # Експорт/резервні копії - Експорт вибраних днів у ZIP (JSON+вкладення), зашифрований паролем (Argon2id + AES-GCM). - Імпорт з валідацією хешів. # MVP → V1 (пріоритети) **MVP (коротко):** - Стіни-за-днями, додавання карток, мініатюри (img/pdf/link/txt), пошук FTS5, PIN-лок, парування QR, E2EE синх, переглядач у додатку. **V1:** - Повний в’ювер DOCX/XLSX, тегування/закріплення карток, нагадування, багатокорисувацький робпростір (опційно). . Так же пропиши его в "блоке памяти". Добавь инструкцию для следующих чатов, что бы после добавления в проект очередной полноценной функции, запрашивалось создание нового "блока памяти", создания промежуточной версии с рабочим функционалом. Ну и объедени это все с предыдущим "блоком памяти"